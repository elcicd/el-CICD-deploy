= el-CICD Chart Reference Documentation
:source-highlighter: rouge
:icons: font
:sectnums:
:sectnumlevels: 4
:toc:
:toclevels: 3

====
CAUTION: **WORK IN PROGRESS**
====

== Overview

Helm is an excellent package management tool for deploying to Kubernetes, but it falls short when it comes to defining Kubernetes manifests through its templates.  Creating templates in Helm can be difficult to learn and master, has no support for Kubernetes resources, and it provides no support and is a poor tool for configuration management.

=== Issues with Helm templates

Verbose::

Helm/Go templates and associated values files are verbose, and assume a good understanding of the Kubernetes resources required when creating templates.  Multiple copies of the same resource type with varying structural content can require multiple copies of the same, verbose boilerplate, because reuse of YAML is not directly supported, either.

Obtuse::

Helm/Go Template syntax and the supporting Sprig library is not very user friendly, which can be a steep learning curve even for experienced developers.

Brittle::

Configuration management isn't supported by Helm.  If structural changes are needed depending on the deployment context, charts can require significant rework to support each environment and/or configuration.

It's code::

Helm templates are code.  This means Helm charts need to be tested as if they are software, and any changes to the templates in chart also require testing.  This testing is separate from whatever they are meant to deploy.

=== A better way to create templates in Helm

el-CICD Chart is a 100% compatible Helm chart that does away with the need for Go templates and replaces it with a much simpler and -- in some cases -- more flexible alternative for defining deployments to Kubernetes.  No other tool is required other than Helm, and el-CICD Chart only uses strict YAML for defining it's deployment definitions.  The goal is to make sure there is no need to ever define a Helm/Go template again, and turn Helm into an effective YAML templating tool.

With el-CICD Chart values.yaml files have the following features:

Variables::

Define el-CICD Chart variables, which can hold any valid YAML type.

YAML templates::

Create templates for any arbitrary YAML.

Leverage built-in Kubernetes templates::

Use pre-defined templates for many Kubernetes resources to further reduce the amount of boilerplate needed.

Deployment profiles::

Define __deployment profiles__, which allow multiple definitions of the same resources to be quickly defined in the same values.yaml file.

Adding these easy to use features to Helm's values.yaml files significantly reduces the amount of boilerplate necessary to define Kubernetes deployments, as well as significantly reducing the learning curve needed to write them.

== Deployment definitions

In el-CICD Chart, a collection of one or more https://helm.sh/docs/chart_template_guide/values_files/[Helm values.yaml files] defining a deployment will be referred to as a **__deployment definition__**.  These are the only files required to be written by the end user for deploying to Kubernetes when used in conjunction with Helm and el-CICD Chart.  It was a fundamental requirement when designing el-CICD Chart that it remain 100% compatible with Helm, and only requiring values.yaml files for use was how the requirement was met.

A deployment definition consists of el-CICD Chart templates for defining what is rendered through Helm, variables for defining any reusable data the templates need, and deployment profiles to support different configurations among the same templates.  el-CICD Chart adds built-in Kubernetes resource definitions with reasonable default values in order to further reduce boilerplate.

NOTE: For the remainder of this document, "templates" will refer only to el-CICD Chart templates, and **NOT** Helm templates.

=== Basic structure

The basic structure of an el-CICD Chart deployment definition is as follows:

[source,YAML,linenums,subs=+quotes]
----
elCicdDefs(-__<unique identifier 1>__)(-__<unique identifier 2>__): # <1>
  <SOME_VARIABLE_NAME>: <some-value>
  ...

elCicdTemplates(-__<unique identifier>__): # <2>
- template(Name): <built-in-template-name>
  ...
----
<1> `elCicdDefs` or `elCicdDefs-*` are maps of variables and their values.
.. Variables can be any valid YAML string.
.. Variable values can be any valid YAML type.
.. Variables can incorporate other variable references within them.
.. Can have optional unique identifiers defined after the `elCicdDefs-` prefix.
... Refers to an object name and/or a deployment profile.
... Only one of each is allowed.
... Each must follow their naming requirements or they will be ignored.
<2> `elCicdTemplates` or `elCicdTemplates-*` are lists of el-CICD Chart templates.
.. Templates can be either built-in el-CICD Chart templates referenced by name (templateName), or are expressed as the complete YAML to be rendered (template).
.. Variables can be referenced within templates.
.. Can have optional unique identifier defined after the `elCicdTemplates-` prefix.
... Ensures each list of templates is not overwritten when Helm merges the values.yaml files.  They have no other meaning.
... All `elCicdTemplates-*` lists will be concatenated to `elCicdTemplates` before processing.

=== Deployment Profiles

**__Deployment profiles__** are the primary mechanism by which el-CICD Chart supports configuration management within a deployment definition.

Deployment profiles are generally defined on the command line in a list using the `elCicdProfiles` identifier:

`helm upgrade --install --set elCicdProfiles='{<PROFILE_1>,...,<PROFILE_N>}' ...`

Profiles must start and end with an upper case alphanumeric character, and may contain any number of upper case alphanumeric characters delimited by either a single `_` or `.`.  The https://pkg.go.dev/regexp/syntax[regular expression] for a profile is:

`[A-Z0-9]+(?:[._][A-Z0-9]+)*`

Profile naming standards were defined so that they could never be confused with a `objName`.

A profile is said to be **__active__** during the rendering of a deployment definition if included in the `elCicdProfiles` list.

Within a deployment definition, profiles are defined as either a discriminator for a map of <<Variables,variables>> or as condition for <<Template filtering, filtering templates>>.  Which deployment profiles are active at rendering will determine which values are ultimately assigned to variables and whether a template is rendered or not.  This is how a single deployment definition can easily hold multiple different configurations.

The default deployment profile is an empty list; i.e. no active profiles.  If more than one profile is active at a time, precedence is defined as least to greatest in the order of the list per Helm convention.

=== Templates

el-CICD Chart templates are defined in one or more lists starting with `elCicdTemplates`:

[source,YAML,linenums,subs=+quotes]
----
elCicdTemplates(-__<unique identifier>__): # <1>
- templateName: <built-in-template-name>  # <2>
  ...
- template: # <3>
    <full-yaml-definition>
  ...
----
<1> List of el-CICD Chart templates.
<2> el-CICD Chart template using a built-in helper template.
<3> el-CICD Chart template defined by its full YAML definition.

In order to support multiple values.yaml files for flexibility and modularity when rendering deployment definitions with Helm, multiple `elCicdTemplates` lists may be defined using the optional unique identifier suffixes.  The order the lists and templates is irrelevant.  All `elCicdTemplates` lists will be concatenated before processing.  Each list name should be unique per deployment definitions, or the Helm rules for merging values.yaml will overwrite matching lists.  The text after `elCicdTemplates-` can be any valid YAML string.

.Example deployment definition with three `elCicdTemplates` lists
[source,YAML,linenums]
----
elCicdTemplates:
- templateName: <built-in-template-name>
  ...

elCicdTemplates-my-secondList:
- templateName: <built-in-template-name>
  ...

elCicdTemplates-WITH_YAML:
- template:
    <full-yaml-definition>
  ...
----

==== Types of templates

el-CICD Chart supports two types of templates:

* **Built-in templates**: Predefined templates within el-CICD Chart.
** Includes many predefined defaults and helper attributes to make rendering resources simpler and less verbose.
** Requested with the <<Built-in templates,`templateName`>> key to use a single built-in or <<Compound Built-in templates,`templateNames`>> to use more than.
* **Free form templates**: Templates of plain YAML that define all or most of resource to be rendered.
+
Free form templates use the `template` key to define a full YAML template.

==== Helper attributes

All el-CICD templates, whether YAML or helper, have a number of helper attributes.  Helper attributes are any attributes not under the `template` key.  The list and their function is as follows.

* `**rawYaml**`: Only applies to free form templates.  If `true`, el-CICD Chart will not attempt to render the required Kubernetes `metadata` map.
* `**objName**`: Name of the resource to be rendered.  For Kubernetes compatible resources, this corresponds directly to `metadata.name`.
* `**namespace**`: Kubernetes namespace to deploy the resource.  Directly corresponds to `metadata.namespace`.
* `**labels**`: Renders a map of labels to `metadata.labels`.
* `**annotations**`: Renders a map of labels to `metadata.annotations`.

===== Template filtering

**__Filters__** are special types of helper attributes the determine whether a template is rendered or not.  Each is a list of one or more profiles.  The act of defining an element in any of the lists below is one way in which profiles are defined in deployment definitions.

* `**mustHaveAnyProfile**`: if any profile in this list is active, render the template.
* `**mustHaveEveryProfile**`: if every profile in this list is active at the same time, render the template.
* `**mustNotHaveAnyProfile**`: if any profile in this list is active, do **NOT** render the template.
* `**mustNotHaveEveryProfile**`: if every profile in this list is active at the same time, do **NOT** render the template.

Each of the above may be used in combination with each other, and their order of precedence is not defined.


.Example of template filtering
[source,YAML,linenums]
----
elCicdTemplates:
- templateName: <built-in-template-name>
  objName: obj-1
  mustHaveAnyProfile: [PROFILE_1, PROFILE_2] # <1>
  ...

elCicdTemplates-with-yaml:
- mustHaveEveryProfile: [PROFILE_1, PROFILE_2] # <2>
  objName: obj-2
  template:
    <full-yaml-definition>
  ...

elCicdTemplates-second-list:
- templateName: <built-in-template-name>
  objName: obj-3
  mustNotHaveAnyProfile: [PROFILE_1, PROFILE_2] # <3>
  ...

elCicdTemplates-with-yaml:
- mustNotHaveEveryProfile: [PROFILE_1, PROFILE_2, PROFILE_3] # <4>
  objName: obj-4
  template:
    <full-yaml-definition>
  ...
----
Given `elCicdProfiles='{PROFILE_1,PROFILE_3}'`; i.e. `PROFILE_1` and `PROFILE_3` are active:

<1> `mustHaveAnyProfile` requires either PROFILE_1 or PROFILE_3 to be active, so `obj-1` **IS** rendered.
<2> `mustHaveEveryProfile` requires both PROFILE_1 and PROFILE_2 to be active, so `obj-2` is **NOT** rendered.
<3> `mustNotHaveAnyProfile` requires neither PROFILE_1 or PROFILE_2 to be active, , so `obj-3` is **NOT** rendered.
<4> `mustNotHaveEveryProfile` requires PROFILE_1, PROFILE_2, and PROFILE_3 to not all be active at the same time, so `obj-4` **IS** rendered.

===== Matrices

**__Matrices__** are a special kind of helper attribute.  Matrices are lists of strings, and el-CICD Chart will generate a __copy of the template__ for each element in the matrix.

el-CICD Chart currently only supports two matrix keys:

* `objNames`: Sets the `objName` helper attribute to match the element for each copy.
* `namespaces`: Set the `namespace` helper attribute to match the element for each copy.

When using matrices, the `objName` and `namespace` attributes can used to define how the final value will be rendered with the following patterns:

* `$<>`: Inserts the literal value from the matrix.
* `$<#>`: Inserts the index of the value in the matrix list.

.Example use of `objNames` and `namespaces` matrices
[source,YAML,linenums]
----
elCicdTemplates:
- templateName: <built-in-template-name>
  objNames: [foo, bar]  # <1>
  namespaces: [zip, zap] # <2>
  objName: $<>-static-text-$<#> # <3>
  namespace: $<>-some-text-$<#> # <3>
----
<1> Will generate two copies of this template for rendering; this template will then be ignored.
<2> Will generate two copies of the template, one for each namespace.
+
IMPORTANT: When using the `namespaces` matrix, you must explicitly list the release namespace, `$<HELM_RELEASE_NAMESPACE>`, in order to deploy a copy there.
<3> Pattern to generate final name and namespace; e.g. <objNames element>-static-text-<index of element>

The above example template results in the following output:

.Example of templates generated from `objNames` and `namespaces` matrices
[source,YAML,linenums]
----
elCicdTemplates:
- templateName: <built-in-template-name>
  objName: foo-static-text-1
  namespace: zip-some-text-1

- templateName: <built-in-template-name>
  objName: bar-static-text-2
  namespace: zip-some-text-1

- templateName: <built-in-template-name>
  objName: foo-static-text-1
  namespace: zap-some-text-2

- templateName: <built-in-template-name>
  objName: bar-static-text-2
  namespace: zap-some-text-2
----

==== Built-in templates

el-CICD Chart defines a number of pre-defined templates in order to further reduce end-user boilerplate, and these are referred to as **__built-in templates__**.  By convention, the names of built-in templates reflect the Kubernetes object they are to render; e.g. `deployment` for a Deployment and `horizontalPodAutoscaler` for a HorizontalPodAutoscaler.  Built-in templates are requested via the `templateName` key.

.Example using the ConfigMap built-in template
[source,YAML,linenums]
----
elCicdTemplates:
- templateName: configMap # <1>
  objName: my-configmap # <2>
  labels: # <3>
    my-label: my-app
  data: # <4>
    a-key: a-value
    b-key: b-value
----
<1> Built-in template to render.
<2> Eventual name of the rendered object; i.e. `metadata.name`.
<3> Helper attribute rendered to `metadata.labels`.
<4> Helper attribute rendered to `configmap.data`.

The above example template results in the following output:

.Example ConfigMap rendered from built-in template
[source,YAML,linenums]
----
apiVersion: v1 # <1>
kind: ConfigMap # <1>
metadata: # <1>
  name: my-configmap  # <2>
  labels:
    my-label: my-app  # <3>
data:  # <4>
  a-key: a-value
  b-key: b-value
----
<1> ConfigMap `apiVersion`, `kind`, and `metadata` map for a Kubernetes object from the built-in `configMap` template.
<2> `metadata.name` generated from `objName`.
<3> `metadata.labels` generated from `labels`.
<4> `data` map generated from `data` helper attribute.

Some built-in templates only include helper attributes that reflect their normal attributes, such as the ConfigMap example above, and are small conveniences for reducing unnecessary boilerplate.  Some built-ins have a few extra helper attributes that significantly reduce the amount a boilerplate needed to define a complete object.  See the <<Built-in Templates>> section for a complete list of all built-ins and their helper attributes.

NOTE: The current set of built-in templates focus almost exclusively on application deployments and supporting Kubernetes resources.  It is hoped that el-CICD Chart will be able to fully support all Kubernetes resources in the future, as well as some popular Custom Resource Definitions.

===== Compound Built-in templates

In order to further reduce excess boilerplate, el-CICD Chart allows defining **__compound built-in templates__**.  Compound built-in templates combine more than one built-in template definitions into a single definition with each individual built-in re-using any shared helper attributes.  Compound built-in templates are defined as a list of one more strings under the `templateNames` key.

.Example Deployment, Service, and Ingress as individual built-in templates
[source,YAML,linenums]
----
elCicdTemplates:
- templateName: deployment # <1>
  objName: my-app
  image: <some-image>
  port: 8080 # <2>

- templateName: service # <1>
  objName: my-app
  port: 8081 # <2>
  targetPort: 8080 # <3>

- templateName: ingress # <1>
  objName: my-app
  host: example.com
  port: 8081 # <2>
----
<1> `templateName` of the `deployment`, `service`, and `ingress` built-in templates individually defined.
<2> `port` is defined differently on the separate templates for illustrative purposes.
<3> `targetPort` needs to match the `deployment` port.

.Example Deployment, Service, and Ingress as a single compound templates
[source,YAML,linenums]
----
elCicdTemplates:
- templateNames: [deployment, service, ingress] # <1>
  objName: my-app # <2>
  image: <some-image>
  host: example.com
  port: 8081 # <3>
  targetPort: 8080 # <4>
----
<1> `templateNames` defines this template as combining a deployment, service, and ingress.
+
TIP: For more concise compound templates, take advantage of the fact that YAML is a superset of JSON and use JSON-like list notation.
<2> `objName` is shared among all three resources.
<3> `port` is shared between the `service` and the `ingress`.  If the `service's` outward and inward facing `port's` were the same, only the `port` attribute would need to be defined.
<4> `targetPort` is also a helper attribute of `deployment` that has precedence over a `port` definition, making this compound template equivalent to individually defined templates in the previous example.

===== Default Values

Many built-in templates have reasonable default values defined in order to further reduce boilerplate; e.g. if the `port` and `targetPort` are the same and the default value (8080) is sufficient, and the release name is sufficient as a `metadata.name`:

.Deployment and Service as compound built-in templates
[source,YAML,linenums]
----
elCicdTemplates:
- templateNames: [deployment, service]
  image: <some-image>
----

The above is the minimal amount that's needed in a deployment definition for a simple deployment of an application to a Kubernetes cluster using el-CICD Chart.  Add the `ingress` built-in to the list and define the `host` helper attribute if the application is accessible from outside the cluster.

==== Free Form Templates

If more complex template definitions are required, or a built-in template doesn't exist for a resource, a **__free form template__** can be defined. Free form templates are just fully defined YAML definitions of resources.  While more verbose than using the simpler, built-in templates, Kubernetes is infinitely extensible with https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/[Custom Resource Definitions] (CRD's), and having free form templates means that no matter what CRD's are introduced now or in the future, el-CICD Chart deployment definitions can adapt without requiring the user to resort to creating new Helm/Go templates.

For example, https://argo-cd.readthedocs.io/en/stable/[ArgoCD] is a popular GitOps solution for managing deployments to Kubernetes cluster, but el-CICD Chart currently has no built-in templates to support an ArgoCD https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#applications[Application], but with free form templates this isn't an issue:

.Defining an ArgoCD Application for my-app
[source,YAML,linenums]
----
elCicdTemplates:
- template:
    apiVersion: argoproj.io/v1alpha1
    kind: Application
    metadata:
      name: my-application-name
      namespace: argocd
    spec:
      project: default
      source:
        repoURL: https://my-git-server.com/my-org/my-app.git
        targetRevision: HEAD
        path: my-app
      destination:
        server: https://kubernetes.default.svc
        namespace: my-app-namespace
----

Built-in templates are a convenience, and not a necessity.  The advantage of free form templates are that they can still use all other features of el-CICD Chart, which means easier templating and configuration management.  Anywhere a built-in template is used a YAML template can be substituted, and vice versa if a built-in template exists for the object being rendered; however, if a `templateName` or `templateNames` are defined, `template` will be ignored.

=== Variables

In traditional Helm, https://helm.sh/docs/chart_template_guide/values_files/[Helm values.yaml files] are static YAML files that are fed to a chart consisting of
Helm/Go templates and processed to produce resource definitions for deployment to Kubernetes.  In order to simplify defining templates and move away from Helm/Go templates, defining variables in deployment definitions was implemented.

==== Defining

Variables are defined in YAML maps named starting with `elCicdDefs` either at the root of a document or within a <<Templates,template>>.  Variables may contain any any valid YAML syntax and type.

.Example el-CICD variable definitions by type
[source,YAML,linenums]
----
elCicdDefs: # <1>
  STRING: string  # <2>

  MULTILINE_STRING: |- # <3>
    long
    multiline
    text

  BOOLEAN: true # <4>

  NUMBER: 10 # <5>

  MAP: # <6>
    foo: bar

  LIST: # <7>
  - foo
  - bar
----
<1> The `elCicdDefs` map defines the default set of variables for a deployment definition.
<2> A variable representing a string.
<3> A variable representing a multiline string.
<4> A variable representing a boolean.
<5> A variable representing a number.
<6> A variable representing a map.
<7> A variable representing a list.

Variable names must are defined by strings of alphanumeric characters or `_` and optionally delimited by single dashes, `-`.  The https://pkg.go.dev/regexp/syntax[regular expression] for a variable name is

`[\w]+?(?:[-][\w]+?)*`

By convention, variables are defined with UPPER_SNAKE_CASE, similar to scripting in shell, but this is not a requirement.

.Example valid and invalid variables
[source,YAML,linenums]
----
elCicdDefs:
  VALID_VAR: is-valid
  valid-VAR: is-valid
  1-valid-var: is-valid

  -invalid-var: dash-at-the-beginning
  INVALID_VAR-: dash-at-the-end
  INVALID--VAR: double-dashes-middle-of-definition
----

TIP: Invalid variable definitions that are valid YAML are simply ignored.  It is not el-CICD Chart's place to flag valid YAML, and it should be pretty easy to debug any issues by looking at the eventual output.

==== Referencing

Variables are referenced with the following syntax:

`$<...>`

Escaping a variable performed with a backslash:

`\$<...>`

This notation was chosen for two reasons:

* No scripting languages use it, making the templating of scripts in other languages within an deployment definition straightforward.
* Variables and their references are valid YAML both as keys in maps and as values in strings, maps, and lists.  Helm requires that values.yaml files (and therefore el-CICD Chart deployment definitions) be valid YAML.

Because of the way Helm works, `elCicdDefs` variable maps are read in completely with the rest of the deployment definition, and each final variable reference value is only determined during processing; therefore, variables do **NOT** have to be defined before being referenced.

.Example of variables referencing other variables
[source,YAML,linenums]
----
elCicdDefs:
  OTHER_VARIABLE: $<VARIABLE> # <1>

  VARIABLE: some-name # <2>

  $<OTHER_VARIABLE>: final-value # <3>

  ESCAPED_VARIABLE: \$<LITERAL_VALUE> # <4>

  FOO: foo
  BAR: bar
  $<$<FOO>$<BAR>>: dynamic-$<FOO>$<BAR>-value # <5>
----
<1> `OTHER_VARIABLE` references `VARIABLE` (defined  immediately afterwards), and therefore has the value `some-name`.
<2> `VARIABLE` has the value of `some-name`.
<3> `OTHER_VARIABLE` is referenced as the key to a variable; therefore, a variable is defined as `some-name` with the value `final-value`.
<4> `ESCAPED_VARIABLE` has the string value "`$<LITERAL_VALUE>`", which is **NOT** a variable reference, because of the `\` in front of the `$` escaping it.  Note that the final value of `ESCAPED_VARIABLE` does **NOT** contain the backslash.  Backslashes are removed during processing.
<5> `FOO` and `BAR` are dynamically used to define the variable `foobar`, with a value of `dynamic-foobar-value`

==== Built-in variables

el-CICD Chart defines a number of built-in variables for use in templates, Helm and template.

===== Helm built-in variables

el-CICD Chart has a few built-in variables derived from https://helm.sh/docs/chart_template_guide/builtin_objects/[Helm's built-in objects].

.el-CICD Chart Helm built-in variable examples
[source,YAML,linenums]
----
elCicdDefs:
  MY_RELEASE_NAME: $<HELM_RELEASE_NAME> # <1>
  MY_RELEASE_NAMESPACE: $<HELM_RELEASE_NAMESPACE> # <2>
----
<1> `**HELM_RELEASE_NAME**` is equivalent to `.Release.Name`, the release name when deployed.
<2> `**HELM_RELEASE_NAMESPACE**` is equivalent to `.Release.Namespace`, the release namespace when deployed.

===== Template built-in variables

Each template has it's own set of built-in variables set when being processed for use in deployment definitions:

.el-CICD Chart template built-in variable examples
[source,YAML,linenums]
----
elCicdDefs:
  MY_OBJ_NAME: $<OBJ_NAME> # <1>
  MY_BASE_OBJ_NAME: $<BASE_OBJ_NAME> # <2>
  MY_NAME_SPACE: $<NAME_SPACE> # <3>
  MY_BASE_NAME_SPACE: $<BASE_NAME_SPACE> # <4>
----
<1> `**OBJ_NAME**`: value of the `objName` helper attribute.
<2> `**BASE_OBJ_NAME**`: value of an element from the `objNames` <<Matrices,matrix>> that `objName` was derived from.  Will default to the value of `OBJ_NAME` if `objNames` is undefined.
<3> `**NAME_SPACE**`: namespace the resource will be deployed to.  Defaults to `HELM_RELEASE_NAMESPACE`.
<4> `**BASE_NAME_SPACE**`: value of an element from the `namespaces` matrix.  Will default to the value of `NAME_SPACE` if `namespaces` is undefined.

==== Scoping

`elCicdDefs` map definitions have two different scopes:

* **Deployment**
+
All `elCicdDefs` maps defined outside of templates; i.e. defined from the root of the deployment definition.  Covers every template in the deployment definition.
* **Template**
+
All `elCicdDefs` maps defined under a specific template.

.Example of deployment and template `elCicdDefs` map definitions
[source,YAML,linenums]
----
elCicdDefs: # <1>
  VAR: a-var

elCicdTemplates:
- templateName: <template name>
  objName: first-template
  elCicdDefs: # <2>
    INNER_VAR: an-inner-var
- templateName: <template name>
  objName: second-template
----
<1> `elCicdDefs` defined at the root of the deployment definition are said to have **__deployment scope __**.  `VAR` can be used by `first-template` and `second-template`.
<2> `INNER_VAR` is only available to the `first-template`, because its `elCicdDefs` map is defined directly under it.

==== Overriding

Variables may be overridden in el-CICD Chart by defining more specific`elCicdDefs` maps.  The types of `elCicdDefs` maps are:

* **Profile**
+
`elCicdDefs-<PROFILE_NAME>` maps defined for a specific deployment profile.  Only one profile may be named.
* **objName**
+
`elCicdDefs-<OBJ_NAME>` maps defined for a specific `objName` or `BASE_OBJ_NAME`.  Only one `objName` may be named.
* **Profile** and **objName**
+
`elCicdDefs-<PROFILE_NAME>-<OBJ_NAME>` or `elCicdDefs-<OBJ_NAME>-<PROFILE_NAME>` maps defined for a specific deployment profile and `objName`.  Only one `objName` and one profile may be named.

.Example of different `elCicdDefs` map definitions
[source,YAML,linenums]
----
elCicdDefs: # <1>
  VAR: a-var

elCicdDefs-PROFILE: # <2>
  VAR: a-var

elCicdDefs-obj-name: # <3>
  VAR: a-var

elCicdDefs-PROFILE-obj-name: # <4>
  VAR: a-var

elCicdDefs-obj-name-PROFILE: # <4>
  VAR: a-var
----
<1> Default `elCidDefs` map.
<2> Profile specific `elCidDefs` map.  Only applies if `PROFILE` is active.
<3> `objName`  specific `elCidDefs` map.  Only applies to resources where the `objName` or `BASE_OBJ_NAME` match.
<3> Profile and `objName` specific `elCidDefs` maps.  Only applies when `PROFILE` is active and to resources where the `objName` or `BASE_OBJ_NAME` match.

Every type of `elCicdDefs` maps may be defined for the deployment or a specific template.

===== Order of precedence

Order of precedence determines which `elCicdDefs` map determines the ultimate value of a variable if it is defined in multiple variable maps.

From least to greatest:

. `**elCicdDefs**`: default.
. `**elCicdDefs-<PROFILE>**`
.. `PROFILE` is an active profile.
.. Deployment profiles' precedence is from least to greatest in the `elCicdProfiles` list.
. `**elCicdDefs-<BASE_OBJ_NAME>`
+
An element from an `objNames` list.
. `**elCicdDefs-<objName>**`
+
The `objName` value of a template.
. `**elCicdDefs-<PROFILE>-<BASE_OBJ_NAME>**`
. `**elCicdDefs-<BASE_OBJ_NAME>-<PROFILE>**`
. `**elCicdDefs-<PROFILE>-<objName>**`
. `**elCicdDefs-<objName>-<PROFILE>**`

All template specific `elCicdDefs` will have precedence over deployment `elCicdDefs`.

.Example of precedence with `elCicdDefs` maps and active deployment profile `PROFILE`
[source,YAML,linenums]
----
elCicdProfiles: [PROFILE]

elCicdDefs:
  VAR: a-value

elCicdDefs-PROFILE:
  VAR: a-profile-value

elCicdDefs-obj-name:
  VAR: an-obj-name-value

elCicdTemplates:
- templateName: <template name>
  objName: obj-name  # <1>
  elCicdDefs:
    VAR: final-value

- templateName: <template name>
  objName: an-obj-name-value  # <2>

- templateName: <template name>
  objName: obj-name-3  # <3>
----
<1> `VAR == final-value`, because the template `elCicdDefs` overrides all deployment `elCicdDefs` maps.
<2> `VAR == an-obj-name-value`, because `elCicdDefs-<objName>` has precedence over `elCicdDefs-<profile>`.
<3> `VAR == a-profile-value`, because `elCicdDefs-<profile>` has precedence over `elCicdDefs`, and there's no matching `elCicdDefs-<objName>` map.

TIP: To null a variable out, define it with an empty value in a higher precedence `elCicdDefs` map.

== Rendering Process Overview

A high level overview of how el-CICD Chart processes and renders deployment definitions.  How and when variables are realized is also explained.

. **Realize Dynamic `elCicdDefs-*` Names**
+
`elCicdDefs` map names may be defined with variables; e.g. `elCicdDefs-$<FOO>`.  All of the deployment `elCicdDefs` map names are processed first.
+
IMPORTANT: **ONLY values defined in the default deployment `elCicdDefs` can be used to define deployment `elCicdDefs-*` maps.**

. **Create Profile-based `elCicdDefs`**
+
Collect final values `elCicdDefs` based on deployment profiles only; i.e. consider only `elCicdDefs-<PROFILE>` maps.

. **Collect and Filter All Templates**
+
`elCicdTemplate-*` lists are collected and concatenated to create an intermediate `elCicdTemplates` list.  <<Template filtering,Filter>> this list based on the active profiles.

. **Expand Matrixes:**
+
<<Matrices,Matrix>> values and lists can be parameterized with variables; e.g. `namespaces: $<NAMESPACE_LIST>` or `objNames: [$<FOO>,$<BAR>]`.  Using the profiles-based `elCicdDefs` map, process the matrix variable references, and then generate all copies for any templates with matrices defined to create a final `elCicdTemplates` list.
+
IMPORTANT: **Only values derived from profile-based deployment `elCicdDefs` map can be used as variables in matrices.**

. **Process Templates**
+
For each template in the final template list:
+
.. Use the active profiles and the `objName` to derive the final deployment `elCicdDefs` for the template.
.. Using the final deployment `elCicdDefs` map as the starting point, process all template `elCicdDefs` to derive the final `elCicdDefs` map for the template.
.. Using the final `elCicdDefs` map for the template, replace ALL remaining variable references in the template.
.. If any escaped el-CICD Chart variable references exist, remove the backslash; e.g. `\$<FOO>` becomes `$<FOO>`.

. **Render the Templates to YAML**

.. If `templateName` or `templateNames` are defined, process the named templates.
.. If `templateName` or `templateNames` are NOT defined, render the value of `template`.

. **Output Final Metadata**
+
In YAML comments, output:

* The list of active profiles
* A list of each template skipped due to filtering.
* A list of each template rendered.

This concludes the el-CICD Chart rendering process.

== Specialized Utilities

=== projectedVolumes by labels

=== copyResources

== Debugging utilities

el-CICD Chart supports two utilities to help with debugging deployment definitions.

outputValuesYaml::

If true, output all merged values.yaml files as YAML and exit.  No el-CICD Chart processing takes place.  Templates will **NOT** be rendered to YAML.  Useful for inspecting how Helm merges multiple deployment definition files.

`helm template --set outputValuesYaml=true ...`

valuesYamlToStdOut::

If true, output all values of a processed el-CICD Chart deployment definition as YAML and exit.  Includes all values belonging `elCicdTemplates` and `elCicdDefs` maps and the `elCicdProfiles` list.  Templates will **NOT** be rendered to YAML.  Useful for inspecting the results of a processed deployment definition before the templates are rendered.
+
`helm template --set valuesYamlToStdOut=true ...`

== Unconventional use-cases

Below are a just a few unconventional ways el-CICD Chart can be used.

=== Third-party Helm charts

There are many applications that already Helm charts created for them, and rewriting them to use el-CICD Chart directly might not be possible or useful for a myriad of reasons.  So how can el-CICD Chart still be leveraged for configuration management?  The answer is to define a deployment definition that results in a values.yaml file and pipe it or post-render with a second Helm call to the other chart.

.Example deployment definition for third-party Helm chart
[source,YAML,linenums]
----
elCicdDefs:
  SOME_3RD_PARTY_VALUES_YAML_VAR: a-value

elCicdDefs-SOME_PROFILE:
  SOME_3RD_PARTY_VALUES_YAML_VAR: b-value

elCicdTemplates:
- rawYaml: true # <1>
  objName: values-yaml-comp-1 # <2>
  template: # <3>
    ... 
- rawYaml: true # <1>
  objName: values-yaml-comp-n # <2>
  template: # <3>
    ... 
----
<1> Set `rawYaml` to true so el-CICD only outputs the processed YAML template exactly as written.
<2> Any number of values files can be defined in a single deployment definition.
<3> Create a YAML template for the values.yaml files of the third-party chart.

.Example deploy-to-helm.sh
----
#!/bin/bash
cat - > third-party-chart-values.yaml

helm upgrade --install -f third-party-chart-values.yaml third-party-release elcicd-charts/elcicd-chart 
----

.Example using el-CICD Chart with a Helm `--post-renderer` to deploy third-party chart
----
helm template -f deployment-def.yaml --post-renderer deploy-to-helm.sh 
----

.Example  el-CICD Chart with a pipe to deploy third-party chart
----
helm template -f deployment-def.yaml gen-values-file elcicd-charts/elcicd-chart | \
  helm upgrade --install -f - third-party-release elcicd-charts/elcicd-chart 
----

=== Kustomize

Helm is not good at some things that el-CICD Chart cannot fix on its own; e.g. labeling and/or annotating a random collection of Kubernetes resources.  Or patching resources, for that matter.  https://kustomize.io/[Kustomize] fills the gap in functionality that Helm or el-CICD Chart templates can't address.

`kustomization.yaml` files, though, are notoriously static in nature by design.  Using el-CICD Chart to create a template of a Kustomization in order to make the files dynamic (e.g. for a CICD system) is trivial.

.Example deployment definition kustomization-values.yaml for kustomization.yaml
[source,YAML,linenums]
----
elCicdDefs: {}  # <1>

elCicdTemplates:
- templateName: kustomization # <2>
  fields:  # <3>
    resources:
    - $<RESOURCES_FILE>

    commonLabels:
      elcicd.io/teamid: $<TEAM_ID>
      elcicd.io/projectid: $<PROJECT_ID>
----
<1> `elCicdDefs` is only defined here to note that all variables in this example are expected to be passed in via the command line.
<2> el-CICD Chart has a `kustomization` built-in template so that the normal headers don't need to be defined.
<3> Create the Kustomization definition, and parameterize it where necessary.

.Example `--post-renderer` kustomize.sh 
[source,YAML,linenums]
----
#!/bin/bash
cat - > manifests.yaml

helm template -f kustomization-values.yaml \
  --set-string elCicdDefs.RESOURCES_FILE=manifests.yaml \
  --set-string elCicdDefs.TEAM_ID=my-team \
  --set-string elCicdDefs.PROJECT_ID=my-team-project \
  kustomization-release \
  elcicd-charts/elcicd-chart > kustomization.yaml

kustomize build .
----

.Example using el-CICD Chart with a Helm `--post-renderer` to deploy third-party chart
----
helm upgrade --install -f deployment-def.yaml --post-renderer kustomize.sh my-app elcicd-charts/elcicd-chart
----

== Reference

=== Built-in Objects

=== Built-in Variables

=== Built-in Defaults

=== Default Template Helper Attributes

=== Built-in Templates